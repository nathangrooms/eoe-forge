import { GameState, GameCard, SimulationEvent } from './types';
import { parseAbilities, shouldTrigger } from './abilityParser';
import { executeAbility } from './abilityExecutor';

/**
 * Track which cards have had their ETB triggers fire
 */
const firedETBs = new Set<string>();

/**
 * Check and execute ETB triggers for cards that just entered the battlefield
 * Returns any events generated by triggered abilities
 */
export function checkETBTriggers(state: GameState): SimulationEvent[] {
  const events: SimulationEvent[] = [];
  [state.player1, state.player2].forEach(player => {
    player.battlefield.forEach(card => {
      // Only fire ETB once per card instance
      if (card.wasPlayedThisTurn && !firedETBs.has(card.instanceId)) {
        const abilities = parseAbilities(card);
        abilities.forEach(ability => {
          if (shouldTrigger(ability, 'enters_battlefield')) {
            const abilityEvents = executeAbility(state, ability.effect, card, player.id);
            events.push(...abilityEvents);
            firedETBs.add(card.instanceId);
          }
        });
      }
    });
  });
  return events;
}

/**
 * Check dies triggers when a creature dies
 * This checks ALL permanents on the battlefield for "whenever a creature dies" abilities
 * Returns any events generated by triggered abilities
 */
export function checkDiesTriggers(state: GameState, deadCard: GameCard, controller: 'player1' | 'player2'): SimulationEvent[] {
  const events: SimulationEvent[] = [];

  // Check ALL permanents on ALL battlefields for "dies" triggers
  // These should trigger every time ANY creature dies
  [...state.player1.battlefield, ...state.player2.battlefield].forEach(card => {
    const abilities = parseAbilities(card);
    abilities.forEach(ability => {
      if (shouldTrigger(ability, 'dies')) {
        const abilityEvents = executeAbility(state, ability.effect, card, card.controller);
        events.push(...abilityEvents);
        
        state.log.push({
          turn: state.turn,
          phase: state.phase,
          type: 'ability_triggered',
          player: card.controller,
          description: `${card.name}'s ability triggers (${deadCard.name} died)`,
          cardName: card.name,
          timestamp: Date.now(),
        });
      }
    });
  });

  // Also check if the dead card itself has dies triggers
  const deadAbilities = parseAbilities(deadCard);
  deadAbilities.forEach(ability => {
    if (shouldTrigger(ability, 'dies')) {
      const abilityEvents = executeAbility(state, ability.effect, deadCard, controller);
      events.push(...abilityEvents);
    }
  });

  return events;
}

/**
 * Check attack triggers when creatures attack
 * Returns any events generated by triggered abilities
 */
export function checkAttackTriggers(state: GameState): SimulationEvent[] {
  const events: SimulationEvent[] = [];
  state.combat.attackers.forEach(attacker => {
    const card = state[state.activePlayer].battlefield.find(c => c.instanceId === attacker.instanceId);
    if (card) {
      const abilities = parseAbilities(card);
      abilities.forEach(ability => {
        if (shouldTrigger(ability, 'attacks')) {
          const abilityEvents = executeAbility(state, ability.effect, card, state.activePlayer);
          events.push(...abilityEvents);
        }
      });
    }
  });
  return events;
}

/**
 * Check cast triggers when a spell is cast
 * Returns any events generated by triggered abilities
 */
export function checkCastTriggers(state: GameState, card: GameCard, controller: 'player1' | 'player2'): SimulationEvent[] {
  const events: SimulationEvent[] = [];
  const abilities = parseAbilities(card);
  abilities.forEach(ability => {
    if (shouldTrigger(ability, 'cast')) {
      const abilityEvents = executeAbility(state, ability.effect, card, controller);
      events.push(...abilityEvents);
    }
  });
  return events;
}

/**
 * Clear ETB tracking when game restarts
 */
export function clearTriggerTracking(): void {
  firedETBs.clear();
}
